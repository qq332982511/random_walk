//one pore is 1 um then s =2 um and Dwater = 2 um^2/ms ,so the dt=(ds)^2/(6*D) 
//so dt = 9/12 =0.75 ms
#include "stdafx.h"
#include<iostream>
#include<stdlib.h>
#include<omp.h>//omp加速必备，没有的话上网上找，记得修改工程属性以启动加速
#include<time.h>
#include<random>//c++随机数库

#define LENGTH 200//模型长度
#define HIGHT 200//模型高度
#define WIDTH 200//模型宽度
#define infile "stone.dat"//模型文件名
#define outfile "result.dat"//详细结果输出文件名，用于调试
#define ezfile "eresult.dat"//简化结果输出，用于下一步的计算
#define walkerNum 10000//行走者数量
//#define random() (float)(rand()%10000)/10000.0
#define PI 3.14159265359//圆周率
#define PORE 1//定义孔隙为数值1
#define SKEL 0//定义骨架为数值0
#define SURF 2//定义泥层至少为数值2
#define SIMUTIME 6000//输出的结果次数
#define OUTTIME 1000//每次输出结果进行的模拟时长
#define STEP 0.25//步长，为孔喉的二十分之一为佳
#define STEPTIME STEP*STEP/6.0/2.0//根据步长计算的实际时长
#define PCLAY (1-(1.0 / ((float)temp)))//泥质相对导电几率，靠近骨架递减
//#define PCLAY 0.5//泥质导电几率，恒为0.5
using namespace std;
char ***stoneDate;//以char类型定义储存模型
char walkerVaild[walkerNum];
int walkerNowNum = walkerNum;//有效行走者数量
struct MyStruct
{
	float x, y, z;//行走者的当前坐标
	int cross;//x方向越界值,正为右越界,负为左越界,0为不越界
}walker[walkerNum];
int ReadFile(char ***x)//从inpute文件以字节方式读入大小为长宽高相乘的模型文件
{
	int i, j, k, temp;
	FILE *inputfile = NULL;
	inputfile = fopen(infile, "r");
	if (inputfile == NULL){
		cout << "error in open stone file" << endl;
		return 0;
	}
	for (i = 0; i < HIGHT; i++)
		for (j = 0; j < WIDTH; j++)
			for (k = 0; k < LENGTH; k++)
			{
				fscanf(inputfile, "%c", &x[i][j][k]);

			}
	fclose(inputfile);
	return 1;
}
int BondCheck(float x, float y, float z)//没用
{
	return 1;
}
int BounceBack(int x0, int y0, int z0, int* x, int* y, int* z)//没用
{
	return 1;
}
void ChaChen(int *x, int *y, int *z)//没用,z=x叉乘y
{
	int i, j, k;
	i = x[1] * y[2] - x[2] * y[1];
	j = -1 * (x[0] * y[2] - x[2] * y[0]);
	k = x[0] * y[1] - x[1] * y[0];
	z[0] = i; z[1] = j; z[2] = k;
}
void NormLineReflect(int *point, float *rvector, float *finalvector)//没用,未测试,镜面反射函数,以x,y,z顺序的读入碰撞点的坐标,入射向量,得到出射向量
{
	int i, j, k, line[3], line2[3], nline[3], flag = 0;
	for (i = -1; i <= 1; i++)
		for (j = -1; j <= 1; j++)
			for (k = -1; k <= 1; k++)
			{
				if (i == 0 && j == 0 && k == 0)continue;
				if (stoneDate[point[0] + i][point[1] + j][point[2] + k] == SURF)
				{
					if (flag == 0)
					{
						line[0] = i; line[1] = j; line[2] = k; flag = 1;
					}
					else if (flag == 1)
					{
						if ((line[0] * j == line[1] * i) && (line[1] * k == line[2] * j))
							continue;
						else { line2[0] = i; line2[1] = j; line2[2] = k; flag = 2; }
					}
				}

			}
	if (flag == 2)
	{
		ChaChen(line, line2, nline);
		float temp = sqrt(nline[0] * nline[0] + nline[1] * nline[1] + nline[2] * nline[2]), lon;
		nline[0] /= temp; nline[1] /= temp; nline[2] /= temp;
		lon = rvector[0] * nline[0] + rvector[1] * nline[1] + rvector[2] * nline[2];
		lon *= 2;
		nline[0] *= lon; nline[1] *= lon; nline[2] *= lon;
		finalvector[0] = rvector[0] + nline[0]; finalvector[1] = rvector[1] + nline[1]; finalvector[1] = rvector[1] + nline[1];
	}

}
int RadomWalk(FILE *result)//随机行走函数,将结果输出到result文件
{


	FILE *ezout = NULL;
	ezout = fopen(ezfile, "w");//设定简化输出文件
	float n, pbounce = 0.5;
	int i, j, k, intoit = 0;
	int tx, ty, tz;
	float theta, phi, newx, newy, newz, hx, hy, hz;
	srand(time(NULL));
	std::random_device rd;//初始化随机数对象rd,将在后面的步骤中用于产生均匀分布的随机数
	int walkerStart[walkerNum][3];//保存行走者的初始坐标x,y,z
	for (i = 0; i < walkerNum; i++)
	{
		int temp1, temp2, temp3;

		temp3 = rd()*1.0 / (rd.max())*LENGTH;
		temp1 = rd()*1.0 / (rd.max())*WIDTH;
		temp2 = rd()*1.0 / (rd.max())*HIGHT;
		while (stoneDate[temp2][temp1][temp3] != PORE)
		{
			temp3 = rd()*1.0 / (rd.max())*LENGTH;
			temp1 = rd()*1.0 / (rd.max())*WIDTH;
			temp2 = rd()*1.0 / (rd.max())*HIGHT;
		}
		walkerStart[i][0] = temp3;
		walkerStart[i][1] = temp1;
		walkerStart[i][2] = temp2;
		walker[i].x = temp3;
		walker[i].y = temp1;
		walker[i].z = temp2;
		walker[i].cross = 0;
	}//在孔隙中均匀分布并初始化行走者的
#pragma omp parallel private(theta,phi,newx,newy,newz,hx,hy,hz,i,j,k,tx,ty,tz)//并行标注语句,此处的线程数默认为核心数,即一个核心对应一个线程
	{
		int end, start, tnum = omp_get_thread_num(), numt = omp_get_num_threads();//tnum为当前线程号,numt为总线程数
		if (tnum == (numt - 1))end = walkerNum;
		else
			end = (tnum + 1)*walkerNum / numt;
		start = tnum *walkerNum / numt;//每个线程分配等额的行走者负载
		double rdmax = rd.max();
		for (k = 0; k < SIMUTIME; k++)//输出序号k
		{
			for (j = 0; j < OUTTIME; j++)//迭代序号j
			{
				for (i = start; i < end; i++)//行走者编号i
				{					
					theta = PI*(rd()*1.0 / (rdmax));//级向角,球坐标系
					phi = 2 * PI*(rd()*1.0 / (rdmax));//方向角,球坐标系
					hx = STEP*sin(theta)*cos(phi);
					hy = STEP*sin(theta)*sin(phi);
					hz = STEP*cos(theta);//hx,hy,hz为每步移动步长在x,y,z方向的投影,参考球坐标系下x,y,z的表示
					newx = hx + walker[i].x;
					newy = hy + walker[i].y;
					newz = hz + walker[i].z;//newx,newy,newz表示可能的行走目的地坐标
					tx = (int)newx;
					ty = (int)newy;
					tz = (int)newz;//tx,ty,tz是离散化后的可能的行走目的地坐标,作用是为了在离散的模型空间中寻址
					if (tx >= 0 && tz >= 0 && tx < LENGTH&&ty >= 0 && ty < WIDTH&&tz < HIGHT)//有效区域判断条件
					{
						char temp = stoneDate[tz][ty][tx];//可能目的地的类别缓存
						if (temp == PORE)//当目的地为孔隙时直接移动,即把可能目的地的连续性坐标赋回行走者对象
						{

							walker[i].x = newx;
							walker[i].y = newy;
							walker[i].z = newz;
							continue;
						}
						else if (temp >= SURF)//当目的地为泥层时进行判定,当判定生效即把可能目的地的连续性坐标赋回行走者对象
						{
							if ((rd()*1.0 / rdmax) >= PCLAY )//判定的条件,当随机值(0-1)大于PCLAY时判定成功,则判定成功率为(1-PCLAY)
							{
								walker[i].x = newx;
								walker[i].y = newy;
								walker[i].z = newz;
								continue;
							}
							continue;//判定未生效时执行此句,表示在该时间步内,该行走者未作出有效位移,即产生时间弛豫
						}
						continue;//表示目的地为骨架,不作出有效位移,产生时间弛豫
					}
					else if (tx >= LENGTH&&tz >= 0 && ty >= 0 && ty < WIDTH&&tz < HIGHT)//目的地右越界判定
					{
						newx -= LENGTH;//成功判定右越界后将x的值减去长度值,表示将可能目的地移动到左边界对应区域
						tx = (int)newx;
						char temp = stoneDate[tz][ty][tx];//重做缓存,之后的代码的功能同未越界的情况
						if (temp == PORE)//
						{
							walker[i].cross++;
							walker[i].x = newx;
							walker[i].y = newy;
							walker[i].z = newz;
							continue;
						}
						else if (temp >= SURF)
						{
							if ((rd()*1.0 / rdmax) >= PCLAY)
							{	
								walker[i].cross++;
								walker[i].x = newx;
								walker[i].y = newy;
								walker[i].z = newz;
								continue;
							}
							continue;
						}
						continue;
					}
					else if (tx < 0 && tz >= 0 && ty >= 0 && ty < WIDTH&&tz < HIGHT)////目的地左越界判定
					{
						newx += LENGTH;//成功判定右越界后将x的值减去长度值,表示将可能目的地移动到左边界对应区域
						tx = (int)newx;
						char temp = stoneDate[tz][ty][tx];//重做缓存,之后的代码的功能同未越界的情况
						if (temp == PORE)
						{
							walker[i].cross--;
							walker[i].x = newx;
							walker[i].y = newy;
							walker[i].z = newz;
							continue;
						}
						else if (temp >= SURF)
						{
							if ((rd()*1.0 / rdmax) >= PCLAY)
							{
								walker[i].cross--;
								walker[i].x = newx;
								walker[i].y = newy;
								walker[i].z = newz;
								continue;
							}
							continue;
						}
						continue;
					}
				}
			}
#pragma omp barrier//线程阻塞命令,当执行到此,所有线程必须执行完自己的任务
#pragma omp master//主线程执行命令,下述操作进行规约求出扩散系数,不可并行
			{
				float  temp = 0, sum = 0;
				for (int td = 0; td < walkerNum; td++)
				{
					temp = (walker[td].x + LENGTH*walker[td].cross - walkerStart[td][0])*(walker[td].x + LENGTH*walker[td].cross - walkerStart[td][0]);//计算从0时刻计时,x轴向位移的平方
					sum += temp;//计算所有行走者的轴向位移的平方
				}
				sum /= 6 * (k * OUTTIME + j)*STEPTIME * walkerNum;//平均位移的平方除以总时长再除以6得到在设订的参考扩散值下的三维轴向统计平均的扩散值,计算方法参考爱因斯坦扩散公式
				fprintf(result, "%d simu %f ms And Deff = %f\n", k * OUTTIME + j, (k * OUTTIME + j)*STEPTIME, sum);//记录当前详细数据,此处可修改为输出行走者详细数据以生成动画
				fprintf(ezout, "%f\n", sum);//只记录扩散值,为后续计算提供数据
				system("cls");//清屏
				cout << "running" << (float)k * 100 / SIMUTIME << "%" << endl;//显示执行的百分比
			}
		}
	}//并行区域结束
	cout << "simulation finished" << intoit << endl;//测试语句
	return 0;
}
void TestStone()//测试数据读取是否正确
{
	int i, j, k;
	for (i = 0; i < HIGHT; i++)
	{
		for (j = 0; j < WIDTH; j++)
		{
			printf("%d ", stoneDate[i][j][33]);
		}
		printf("\n");
	}
}
int _tmain(int argc, _TCHAR* argv[])//主程序
{
	int i, j, k;
	FILE *resultfile = NULL;
	srand(time(0));//以系统时间初始化随机数种子,此程序未用到
	stoneDate = new char**[HIGHT];//通过此方法产生3维数组可避免栈空间放不下.也可直接产生一维数组,然后用索引标记
	for (i = 0; i < HIGHT; i++)
		stoneDate[i] = (char**) new char**[WIDTH];
	for (i = 0; i < HIGHT; i++)
		for (j = 0; j < WIDTH; j++)
			stoneDate[i][j] = (char *)new char*[LENGTH];
	resultfile = fopen(outfile, "w");
	if (resultfile == NULL){ cout << "error in opening result file " << endl; return 1; }
	if (ReadFile(stoneDate) == 1)cout << " success in reading file" << endl;
	else {
		cout << " error in reading file" << endl;
		return 1;
	}
	RadomWalk(resultfile);
	cout << sin(0.5*PI) << "  " << cos(0.5*PI) << endl;//测试语句
	fclose(resultfile);
	system("d:\\music.mp3");//程序结束时播放d盘下名为music的mp3文件,作为程序结束的提醒
	//ps:将工程调到release的x64模式可增加运行速度.让工程支持openmp可增加运行速度,减少行走这数目和输出次数可减少时间消耗,但所设时间必须大于收敛时间
	return 0;
}

